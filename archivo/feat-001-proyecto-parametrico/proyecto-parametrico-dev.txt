Tengo un proyecto fullstack y lo quiero volver paramétrico en cuanto al nombre del servicio y a los puertos en los que se expone: 

./
│   ├── .env
│   ├── .gitignore
│   ├── LICENSE
│   ├── README.md
│   ├── docker-compose.override.yml
│   ├── docker-compose.prod.yml
│   ├── docker-compose.yml
├── .vscode/
│   │   ├── launch.json
│   │   ├── settings.json
├── archivo/
│   ├── feat-001-proyecto-parametrico/
│   │   │   ├── proyecto-parametrico-dev.txt
├── backend/
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── requirements.txt
│   ├── app/
│   │   │   ├── __init__.py
│   │   │   ├── main.py
│   │   ├── api/
│   │   │   │   ├── __init__.py
│   │   │   ├── routes/
│   │   │   │   │   ├── cnc.py
│   │   │   │   │   ├── escaneos.py
│   │   │   │   │   ├── health.py
│   │   │   │   │   ├── imputaciones_ip.py
│   │   │   │   │   ├── upload.py
│   │   ├── core/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── sse_manager.py
│   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── cnc_processor.py
│   │   │   │   ├── file_processor.py
│   │   │   │   ├── imputaciones_ip_processor.py
│   │   │   │   ├── seguimiento_escaneos_service.py
│   │   │   │   ├── validation_imputaciones_service.py
│   │   │   ├── imputaciones_ip/
│   │   │   │   │   ├── __init__.py
│   │   │   │   │   ├── _constants_imputaciones.py
│   │   │   │   │   ├── _utils.py
│   │   │   │   │   ├── exporter.py
│   │   │   │   │   ├── loader.py
│   │   │   │   │   ├── transformer.py
│   │   │   ├── utils/
│   │   │   │   │   ├── __init__.py
│   │   │   │   │   ├── cnc_processor_utils.py
│   │   │   │   │   ├── escaneos_utils.py
│   ├── tests/
│   │   │   ├── test_health.py
│   ├── tmp/
│   │   │   ├── AVISOS_CALIDAD.xlsx
├── frontend/
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── default.conf.template
│   │   ├── index.html
│   │   ├── package-lock.json
│   │   ├── package.json
│   │   ├── vite.config.js
│   ├── src/
│   │   │   ├── App.jsx
│   │   │   ├── main.jsx
│   │   │   ├── setupTests.js
│   │   ├── components/
│   │   │   │   ├── FileUploadChecker.jsx
│   │   │   │   ├── Header.jsx
│   │   │   │   ├── ImputacionesIPForm.jsx
│   │   │   │   ├── ImputacionesIPStatus.jsx
│   │   │   │   ├── SideNav.jsx
│   │   ├── contexts/
│   │   │   │   ├── PageContext.jsx
│   │   │   │   ├── ThemeContext.jsx
│   │   ├── hooks/
│   │   │   │   ├── useCNC.js
│   │   │   │   ├── useImputacionesIP.js
│   │   │   │   ├── useSSE.js
│   │   ├── pages/
│   │   │   │   ├── AgregarImputaciones.jsx
│   │   │   │   ├── CargarRespuestaSap.jsx
│   │   │   │   ├── GererarImputaciones.jsx
│   │   │   │   ├── Home.jsx
│   │   │   │   ├── ObtenerFeedback.jsx
│   │   │   │   ├── SubirArchivos.jsx
│   │   │   │   ├── SubirTecos.jsx
│   │   ├── routes/
│   │   │   │   ├── routesAuto.jsx
│   │   ├── services/
│   │   │   │   ├── uploadCNCService.js
│   │   │   │   ├── uploadImputacionesService.js
│   │   │   │   ├── uploadService.js
│   │   ├── styles/
│   │   │   │   ├── main.css
│   │   ├── theme/
│   │   │   │   ├── index.js

# PATH: docker-compose.yml

services:
  frontend:
    container_name: "${SERVICE_NAME}-frontend"
    build:
      context: ./frontend
      dockerfile: Dockerfile
    environment:
      SERVICE_NAME: "${SERVICE_NAME}"
      FRONTEND_PORT: "${FRONTEND_PORT}"
      BACKEND_PORT: "${BACKEND_PORT}"
    depends_on:
      - backend

  backend:
    container_name: "${SERVICE_NAME}-backend"
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      SERVICE_NAME: "${SERVICE_NAME}"
      BACKEND_PORT: "${BACKEND_PORT}"

# PATH: docker-compose.override.yml

services:
  frontend:
    build:
      target: dev
      args:
        SERVICE_NAME: "${SERVICE_NAME}"
        FRONTEND_PORT: "${FRONTEND_PORT}"
    ports:
      - "${FRONTEND_PORT}:${FRONTEND_PORT}"
    volumes:
      - ./frontend/src:/app/src
    environment:
      CHOKIDAR_USEPOLLING: "true"
      CHOKIDAR_INTERVAL: "1000"

  backend:
    build:
      args:
        VITE_SERVICE_NAME: "${SERVICE_NAME}"   
        SERVICE_NAME: "${SERVICE_NAME}"
        BACKEND_PORT: "${BACKEND_PORT}"
    ports:
      - "${BACKEND_PORT}:${BACKEND_PORT}"
      - "5678:5678"
    volumes:
      - ./backend/app:/app/app
      - ./backend/tmp:/app/tmp
    command: ["python", "-m", "debugpy", "--listen", "0.0.0.0:5678", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "${BACKEND_PORT}", "--reload"]

# PATH: frontend/Dockerfile

# ========================
# STAGE 1: Desarrollo
# ========================
FROM node:20-alpine AS dev
ARG SERVICE_NAME
ARG FRONTEND_PORT
ARG BACKEND_PORT

# Para que Vite lea import.meta.env.VITE_SERVICE_NAME, etc.
ENV VITE_SERVICE_NAME=$SERVICE_NAME
ENV VITE_FRONTEND_PORT=$FRONTEND_PORT
ENV VITE_BACKEND_PORT=$BACKEND_PORT

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .

# Exponemos el puerto de Vite (en Docker Compose lo mapeamos al host)
EXPOSE $FRONTEND_PORT
CMD ["npm", "run", "dev"]

# ========================
# STAGE 2: Build de producción
# ========================
FROM node:20-alpine AS build
ARG SERVICE_NAME
ARG FRONTEND_PORT

ENV VITE_SERVICE_NAME=$SERVICE_NAME
ENV VITE_FRONTEND_PORT=$FRONTEND_PORT
ENV VITE_BACKEND_PORT=$BACKEND_PORT

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# ========================
# STAGE 3: Imagen final con Nginx
# ========================
FROM nginx:alpine AS prod

# Copiamos la plantilla de config con variables ${SERVICE_NAME}
COPY default.conf.template /etc/nginx/templates/default.conf.template

# Recogemos el mismo SERVICE_NAME en la etapa final para envsubst
ARG SERVICE_NAME
ENV SERVICE_NAME=$SERVICE_NAME

# Copiamos la carpeta compilada (dist) desde la etapa build
COPY --from=build /app/dist /usr/share/nginx/html

EXPOSE 80
CMD ["sh", "-c", "envsubst < /etc/nginx/templates/default.conf.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]

// PATH: frontend/vite.config.js

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(() => {
  // Lee las variables de entorno definidas en Docker (ENV).
  const serviceName = process.env.VITE_SERVICE_NAME;
  const frontendPort = parseInt(process.env.VITE_FRONTEND_PORT);
  const backendPort = parseInt(process.env.VITE_BACKEND_PORT);

  return {
    define: {
      // inyectar en import.meta.env
      'import.meta.env.VITE_SERVICE_NAME': JSON.stringify(serviceName),
      'import.meta.env.VITE_FRONTEND_PORT': JSON.stringify(frontendPort),
      'import.meta.env.VITE_BACKEND_PORT': JSON.stringify(backendPort),
    },
    base: `/${serviceName}/`,
    plugins: [react()],
    server: {
      host: '0.0.0.0',
      port: frontendPort,
      proxy: {
        '/api': {
          target: `http://${serviceName}-backend:${backendPort}`,
          changeOrigin: true,
        },
      },
    },
  };
});

// PATH: frontend/src/App.jsx

import { Routes, Route } from 'react-router-dom';
import Header from './components/Header';
import SideNav from './components/SideNav';
import routes from './routes/routesAuto';
import Home from './pages/Home'; // Página principal

function App() {
  return (
    <>
      <Header />
      <div style={{ display: 'flex', marginTop: '64px' }}>
        <SideNav />
        <main style={{ flexGrow: 1, padding: '16px' }}>
          <Routes>
            <Route path="/" element={<Home />} />
            {routes.map(({ path, element }) => (
              <Route key={path} path={path} element={element} />
            ))}
          </Routes>
        </main>
      </div>
    </>
  );
}

export default App;

// PATH: frontend/src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { PageProvider } from './contexts/PageContext';
import { ThemeProviderWrapper } from './contexts/ThemeContext';
import App from './App';

const serviceName = import.meta.env.VITE_SERVICE_NAME || '';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <ThemeProviderWrapper>
      <CssBaseline />
      <BrowserRouter basename={`/${serviceName}`}>
        <PageProvider>
          <App />
        </PageProvider>
      </BrowserRouter>
    </ThemeProviderWrapper>
  </React.StrictMode>
);


// PATH: frontend/src/pages/AgregarImputaciones.jsx

import { Box, Typography } from "@mui/material";
import useImputacionesIP from "../hooks/useImputacionesIP";
import ImputacionesIPForm from "../components/ImputacionesIPForm";
import ImputacionesIPStatus from "../components/ImputacionesIPStatus";

export const meta = {
  label: "Agregar Imputaciones", // nombre para el sidebar
  priority: 2              // orden de aparición
};

export default function ImputacionesIP() {
  const {
    files,
    validations,
    setFile,
    validateFile,
    canGenerate,
    isUploading,
    status,
    message,
    error,
    handleGenerate,
    handleCancel,
    handleDownload,
  } = useImputacionesIP();

  return (
    <Box sx={{ textAlign: "center" }}>
      <Typography variant="h5" sx={{ mb:2, mt: 4, fontWeight: "bold", textTransform: "uppercase", letterSpacing: 1 }}>
        Generador de Imputaciones SAP
      </Typography>

      <Typography variant="body1" sx={{ mt: 1, maxWidth: 600, mx: "auto", color: "text.secondary" }}>
        Esta herramienta permite validar los archivos de cierre del departamento IP y generar automáticamente los ficheros de imputación compatibles con SAP. Sigue los pasos a continuación para cargar los datos y obtener los archivos de imputaciones con el formato de SAP
      </Typography>

      <ImputacionesIPForm
        files={files}
        validations={validations}
        setFile={setFile}
        validateFile={validateFile}
        canGenerate={canGenerate}
        onGenerate={handleGenerate}
        isUploading={isUploading}
      />

      <ImputacionesIPStatus
        status={status}
        message={message}
        error={error}
        isUploading={isUploading}
        onCancel={handleCancel}
        onDownload={handleDownload}
      />
    </Box>
  );
}

// PATH: frontend/src/hooks/useImputacionesIP.js

import { useState, useEffect } from "react";
import useSSE from "./useSSE";
import {
  validateImputacionFile,
  startImputacionesProcess,
  cancelImputacionesProcess,
} from "../services/uploadImputacionesService";

export default function useImputacionesIP() {
  // 1) Estados para los 4 archivos y si están validados
  const [files, setFiles] = useState([null, null, null, null]);
  const [validations, setValidations] = useState([false, false, false, false]);

  // 2) Estado del proceso
  const [processId, setProcessId] = useState(null);
  const [isUploading, setIsUploading] = useState(false);
  const [status, setStatus] = useState("idle"); // "idle"|"in-progress"|"completed"|"cancelled"|"error"
  const [message, setMessage] = useState("");
  const [error, setError] = useState("");

  // 3) SSE
  const sseUrl = processId
    ? `${import.meta.env.VITE_API_BASE_URL}/imputaciones-ip/events/${processId}`
    : null;
  const { events } = useSSE(sseUrl);

  // 4) Interpretar eventos SSE
  useEffect(() => {
    if (events.length === 0) return;

    const lastEvent = events[events.length - 1];
    const { type, data } = lastEvent;

    switch (type) {
      case "message":
        setStatus("in-progress");
        setMessage(data);
        break;
      case "completed":
        setStatus("completed");
        setMessage(data);
        break;
      case "cancelled":
        setStatus("cancelled");
        setMessage(data);
        break;
      case "error":
        setStatus("error");
        setError(data);
        break;
      default:
        break;
    }
  }, [events]);

  // ============== FUNCIONES ==============

  /**
   * setFile: actualiza el i-ésimo archivo y reinicia su validación
   */
  function setFile(index, file) {
    const newFiles = [...files];
    newFiles[index] = file;
    setFiles(newFiles);

    const newVals = [...validations];
    newVals[index] = false; // reset validación
    setValidations(newVals);
  }

  /**
   * validateFile: llama al backend para validar este archivo (fake OK)
   */
  async function validateFile(index) {
    const file = files[index];
    if (!file) return;

    try {
      // Aquí podría haber lógica de "comprobar .xlsx" en frontend
      if (!file.name.endsWith(".xlsx")) {
        throw new Error("Debe ser un archivo .xlsx");
      }

      // Llamada al backend (fake por ahora)
      await validateImputacionFile(file, index);
      // Marcar validado
      const newVals = [...validations];
      newVals[index] = true;
      setValidations(newVals);
    } catch (err) {
      alert("Error validando el archivo: " + err.message);
    }
  }

  /**
   * canGenerate: solo se puede generar si las 4 validaciones son true
   */
  const canGenerate = validations.every((val) => val === true);

  /**
   * handleGenerate: inicia el proceso SSE en backend con los 4 archivos
   */
  async function handleGenerate() {
    if (!canGenerate) return;
    try {
      setIsUploading(true);
      const { process_id } = await startImputacionesProcess(files);
      setProcessId(process_id);
      setStatus("in-progress");
      setMessage("Iniciando proceso...");
    } catch (err) {
      alert("Error al iniciar proceso: " + err.message);
    } finally {
      setIsUploading(false);
    }
  }

  /**
   * handleCancel: cancela el proceso SSE
   */
  async function handleCancel() {
    if (!processId) return;
    await cancelImputacionesProcess(processId);
    setProcessId(null);
    setStatus("idle");
    setMessage("");
    setError("");
  }

  /**
   * handleDownload: descarga el resultado final
   */
  function handleDownload() {
    if (!processId) return;
    window.open(
      `${import.meta.env.VITE_API_BASE_URL}/imputaciones-ip/download/${processId}`,
      "_blank"
    );
  }

  return {
    files,
    validations,
    setFile,
    validateFile,
    canGenerate,
    isUploading,
    status,
    message,
    error,
    handleGenerate,
    handleCancel,
    handleDownload,
  };
}

// PATH: frontend/src/services/uploadImputacionesService.js

import axios from "axios";

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

/**
 * Valida un archivo en el backend.
 */
export async function validateImputacionFile(file, index) {
  const formData = new FormData();
  formData.append("file", file);

  await axios.post(
    `${API_BASE_URL}/imputaciones-ip/validate-file?index=${index}`,
    formData,
    {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    }
  );
}

/**
 * Inicia el proceso SSE en backend subiendo los 4 archivos
 */
export async function startImputacionesProcess(files) {
  const formData = new FormData();
  // Añadimos cada archivo con un nombre distinto
  formData.append("file1", files[0]);
  formData.append("file2", files[1]);
  formData.append("file3", files[2]);
  formData.append("file4", files[3]);

  const response = await axios.post(`${API_BASE_URL}/imputaciones-ip/start`, formData, {
    headers: { "Content-Type": "multipart/form-data" },
  });
  return response.data; // { process_id: '...' }
}

/**
 * Cancela el proceso SSE
 */
export async function cancelImputacionesProcess(processId) {
  await axios.post(`${API_BASE_URL}/imputaciones-ip/cancel/${processId}`);
}

# PATH: backend/Dockerfile

FROM python:3.11

ARG SERVICE_NAME
ARG BACKEND_PORT

ENV SERVICE_NAME=$SERVICE_NAME
ENV BACKEND_PORT=$BACKEND_PORT

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# El puerto interno que escucha uvicorn
EXPOSE 8000

# En modo dev se sobreescribe con debugpy en docker-compose.override
CMD ["sh", "-c", "uvicorn app.main:app --host 0.0.0.0 --port $BACKEND_PORT"]

# PATH: backend/app/api/routes/imputaciones_ip.py

from fastapi import APIRouter, Request, UploadFile, BackgroundTasks, Query, HTTPException, File
from fastapi.responses import StreamingResponse, FileResponse
import uuid
import os
import asyncio

from app.core.sse_manager import sse_manager
from app.services.validation_imputaciones_service import validate_imputaciones_file
from app.services.imputaciones_ip_processor import long_running_task 

router = APIRouter()

FILE_TYPES = {
    0: "wbs_por_clave",
    1: "listado_usuarios",
    2: "descarga_imputaciones",
    3: "fichajes_sap"
}

@router.post("/validate-file")
async def validate_file(index: int = Query(...), file: UploadFile = File(...)):
    """
    Endpoint real de validación: guardamos el archivo en /tmp, 
    usamos 'validate_imputaciones_file' para chequear columnas mínimas,
    y si OK, respondemos 200.
    """
    if index not in FILE_TYPES:
        raise HTTPException(status_code=400, detail="Índice de archivo no válido")

    file_type = FILE_TYPES[index]
    if not file:
        raise HTTPException(status_code=400, detail="Se requiere un archivo")

    # Guardar temporalmente
    tmp_path = f"/tmp/validate_{uuid.uuid4()}_{file.filename}"
    with open(tmp_path, "wb") as f_out:
        content = await file.read()
        f_out.write(content)

    # Llamar a la validación
    try:
        validate_imputaciones_file(tmp_path, file_type)
    except ValueError as e:
        # Lanza HTTP 400 si hay error en validación
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        # (Opcional) Podrías borrar el archivo o dejarlo
        pass

    return {"message": f"El archivo '{file_type}' es válido"}


@router.post("/start")
async def start_imputaciones_process(
    file1: UploadFile,
    file2: UploadFile,
    file3: UploadFile,
    file4: UploadFile,
    background_tasks: BackgroundTasks
):
    process_id = str(uuid.uuid4())
    tmp_dir = "/tmp"

    # Guardar los 4 ficheros
    file_paths = []
    for i, f in enumerate([file1, file2, file3, file4], start=1):
        file_path = os.path.join(tmp_dir, f"{process_id}_file{i}_{f.filename}")
        with open(file_path, "wb") as dest:
            content = await f.read()
            dest.write(content)
        file_paths.append(file_path)

    # Iniciamos SSE
    sse_manager.start_process(process_id)

    # Invoca la ETL real, en vez del 'long_running_fake'
    background_tasks.add_task(long_running_task, process_id, file_paths)

    return {"process_id": process_id}


@router.get("/events/{process_id}")
async def sse_events(request: Request, process_id: str):
    """
    Enviamos eventos SSE al frontend hasta que el proceso termine, se cancele o haya error.
    Igual que en cnc.py
    """
    async def event_generator():
        while True:
            if await request.is_disconnected():
                break

            event = sse_manager.pop_next_event(process_id)
            if event:
                event_type, data = event
                yield f"event: {event_type}\ndata: {data}\n\n"

                if event_type in ("completed", "cancelled", "error"):
                    break
            else:
                await asyncio.sleep(0.5)

    return StreamingResponse(event_generator(), media_type="text/event-stream")


@router.post("/cancel/{process_id}")
async def cancel_process(process_id: str):
    """
    Marca el proceso como cancelado (y notifica vía SSE).
    """
    state = sse_manager.get_state(process_id)
    if state:
        sse_manager.mark_cancelled(process_id)
        return {"message": "Proceso cancelado"}
    return {"message": "Proceso no encontrado"}


@router.get("/download/{process_id}")
async def download_imputaciones_result(process_id: str, background_tasks: BackgroundTasks):
    """
    Descarga el archivo resultante (fake). Lo borra tras enviarlo.
    """
    state = sse_manager.get_state(process_id)
    if not state:
        return {"error": "Process ID no encontrado"}

    if state["status"] != "completed":
        return {"error": f"No está completado (status = {state['status']})"}

    result_file = state.get("result_file")
    if not result_file or not os.path.exists(result_file):
        return {"error": "No se encontró el archivo resultante"}

    # Borrar el archivo tras enviarlo
    background_tasks.add_task(os.remove, result_file)

    return FileResponse(
        path=result_file,
        filename=os.path.basename(result_file),
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        background=background_tasks
    )

# PATH: backend/app/api/routes/health.py

from fastapi import APIRouter

router = APIRouter()

@router.get("/health")
def health_check():
  return {"status": "ok"}


No consigo que el frontend se comunique con el backend. Actualmente, debuggeando, no consigo generar una petición válida al backend. Necesito que este endpoint consista en un botón que al pulsarlo recibe la respuesta de health del servidor: 

// PATH: frontend/src/pages/ObtenerFeedback.jsx

export const meta = {
  label: "Obtener Feedback", // nombre para el sidebar
  priority: 5                // orden de aparición
};

export default function LoQueSea() {
  return <div>Hola soy la página LoQueSea</div>;
}

Porque con postman me funciona: 

http://localhost:8000/powersap/api/health

{
    "status": "ok"
}

Necesito ver qué está fallando al generar la petición, es como que no está tomando correctamente las variables de entorno para generar la petición a la api

